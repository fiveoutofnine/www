import type { OnChainMusicFeature } from '@/lib/types/on-chain-music';

export const ON_CHAIN_SONGS: OnChainMusicFeature[] = [
  {
    address: '0x726f636B67eC5941ee63209DD3A8eD2d8A50DBE7',
    chainId: 8453,
    name: 'rocky',
    length: 24.832,
    composition:
      '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {FixedPointMathLib as Math} from "solady/utils/FixedPointMathLib.sol";\n\n/// @title {FiveFiveFive} NFT auditory art\n/// @author fiveoutofnine\n/// @notice A library for generating onchain audio for {FiveFiveFive}, which is\n/// a 24.832 second long audio of a 5-part arrangement of "Gonna Fly Now" by\n/// Bill Conti, popularly known as the theme song from the movie Rocky (1976),\n/// at 117.1875 BPM.\n/// @dev The metadata returned by {FiveFiveFive} doesn\'t use this library for\n/// practical reasons. However, the same result can be yielded by calling\n/// {getSoundValueAtSample} for each sample in the range `[0, 794623]` and\n/// concatenating the result, prefixed with the header returned by\n/// {getAudioWavFileHeader}.\nlibrary FiveFiveFiveAudio {\n    using Math for int256;\n    using Math for uint256;\n\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice A beatmap of when the 1st synth line is active in the audio,\n    /// where each `1` bit represents a 1/64th note, or 1024 ticks, being\n    /// played.\n    /// @dev The beatmap ranges the entire length of 1 cycle for 1/64th notes\n    /// with indices in `[0, 775]`, where the `i`th MSb is the corresponding\n    /// data.\n    bytes internal constant SYNTH_1_BEATMAP =\n        hex"fefeeefeeefeeefefefeeefeeefeeefe00feeefeefeefffefefeeeefeffffeeffe"\n        hex"fffffffffffeeffefffffffffffeeffefffffffffffeeffefffffffffffffffe00"\n        hex"eeffeeeffffffe00eefeefeefffefefefefefefefeffffffffffffffffffff";\n\n    /// @notice A bitpacked value of 8-bit words representing the notes of the\n    /// 1st synth line, where each note is a 1/16th note, or 4096 ticks.\n    /// @dev A value of `0x05` corresponds to C3, and 1 corresponds to a\n    /// semitone. To attain the intended note value, it requires no\n    /// transpositions, so the `_pitch` parameter passed into `_synth` should be\n    /// set to `0`. Also, this value ranges the entire length of 1 cycle for\n    /// 1/16th notes with indices in `[0, 193]`, where the `i`th MSb is the\n    /// corresponding data.\n    bytes internal constant SYNTH_1_NOTES =\n        hex"05050505050505050505090905050505090909090909090909090c0c0909090909"\n        hex"090909090909090909090909090909090909090909090909090909090915181818"\n        hex"1a1a1a1a1a1a1a1a1a1a1a1a1a1c1c1c151515151515151515151515151818181a"\n        hex"1a1a1a1a1a1a1a1a1a1a1a1a1c1c1c151515151515151515151515151515151515"\n        hex"070507070705070909090909090911111111111111111111111111111616151515"\n        hex"1515151515151515151515151515151515151515151515151515151515";\n\n    /// @notice A bitpacked value of 8-bit words representing the notes of the\n    /// 2nd synth line, where each note is a 1/16th note, or 4096 ticks.\n    /// @dev A value of `0x1d` corresponds to C3, and 1 corresponds to a\n    /// semitone. To attain the intended note value, it must be transposed down\n    /// by 2 octaves, so the `_pitch` parameter passed into `_synth` should be\n    /// set to `2e18`. Also, this value ranges 1/16th notes with indices in\n    /// `[16, 165]`, where the `i`th MSb is the corresponding data.\n    bytes internal constant SYNTH_2_NOTES =\n        hex"080808080808080808080808080808081d1d1d1d1d1d1d1d1d1d21211d1d1d1d1c"\n        hex"1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c21242424"\n        hex"212121212121212121212121262828281d1d1d1d1d1d1d1d1d1d1d1d2124242421"\n        hex"212121212121212121212126282828212121212121212121212121212121212121"\n        hex"1f1d1f1f1f1d1f212121212121211d1d1d1d1c1c1c1a1a1a181818181d1d1d1d1d"\n        hex"1d";\n\n    /// @notice A beatmap of when the 1st bass line is active in the audio,\n    /// where each `1` bit represents a 1/64th note, or 1024 ticks, being\n    /// played.\n    /// @dev The beatmap ranges the entire length of 1 cycle for 1/64th notes\n    /// with indices in `[0, 775]`, where the `i`th MSb is the corresponding\n    /// data.\n    bytes internal constant BASS_1_BEATMAP =\n        hex"0000000000000000000000000000000000000000000000fffefffffffffffffffe"\n        hex"fffefffefffefffefffefffefffefffefffefffefffefffefffefffefffefffeff"\n        hex"fefffefffefffe00eefeefeefffefefefeeffefeefffffffffffffffffffff";\n\n    /// @notice A bitpacked value of 8-bit words representing the notes of the\n    /// 1st bass line, where each note is a 1/16th note, or 4096 ticks.\n    /// @dev A value of `0x35` corresponds to C3, and 1 corresponds to a\n    /// semitone. To attain the intended note value, it must be transposed down\n    /// by 4 octaves, so the `_pitch` parameter passed into `_synth` should be\n    /// set to `4e18`. Also, this value ranges the entire length of 1 cycle for\n    /// 1/16th notes with indices in `[0, 193]`, where the `i`th MSb is the\n    /// corresponding data.\n    bytes internal constant BASS_1_NOTES =\n        hex"080808080808080808080808080808080808080808080808080808080808080808"\n        hex"080808080808080808080808082e2e2e2e2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d"\n        hex"2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e303030303030303030303030303030302e"\n        hex"2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e303030303030303030303030303030303232"\n        hex"323232323232303030303030303032323232323232323232303030303030303030"\n        hex"3030303030303030303030303030303030303030303030303030303030";\n\n    /// @notice A beatmap of when the 2nd bass line is active in the audio,\n    /// where each `1` bit represents a 1/64th note, or 1024 ticks, being\n    /// played.\n    /// @dev The beatmap ranges the entire length of 1 cycle for 1/64th notes\n    /// with indices in `[0, 775]`, where the `i`th MSb is the corresponding\n    /// data.\n    bytes internal constant BASS_2_BEATMAP =\n        hex"0000000000000000000000000000000000fffffffffffefffefffffffffffffffe"\n        hex"fefefffeeefefefefefefffeeefefefefefeffeeeefefefefefeffeeeefeeeeeff"\n        hex"ffffeefeffefeefeffffffeefeeeeefeeefefefefeffffffffffffffffffff";\n\n    /// @notice A bitpacked value of 8-bit words representing the notes of the\n    /// 2nd bass line, where each note is a 1/16th note, or 4096 ticks.\n    /// @dev A value of `0x35` corresponds to C3, and 1 corresponds to a\n    /// semitone. To attain the intended note value, it must be transposed down\n    /// by 4 octaves, so the `_pitch` parameter passed into `_synth` should be\n    /// set to `4e18`. Also, this value ranges the entire length of 1 cycle for\n    /// 1/16th notes with indices in `[0, 193]`, where the `i`th MSb is the\n    /// corresponding data.\n    bytes internal constant BASS_2_NOTES =\n        hex"080808080808080808080808080808080808080808080808080808080808080808"\n        hex"082828282828282828282828282222222221212121212121212121212121212121"\n        hex"1f1f1d1d1f1f1f1f29292a2a2b2b1f1f21211f1f212121212b2b2c2c2d2d21211f"\n        hex"1f1d1d1f1f1f2629262a2a2b2b1f1f21211f1f212121282b282c2c2d28211d1f1f"\n        hex"1f1f1f1f1f1f21212121212121212222222222222222222e2e2e2e22222221212d"\n        hex"2d2d2d2d2d212121212121212121212121212121212121212121212121";\n\n    /// @notice A beatmap of when the snare line is active in the audio, where\n    /// where each `1` bit represents a 1/64th note, or 1024 ticks, being\n    /// played.\n    /// @dev The beatmap ranges 1/64th notes with indices in `[236, 711]`,\n    /// where the `i - 236`th MSb is the corresponding data.\n    bytes internal constant SNARE_BEATMAP =\n        hex"ee0e0e0e000e0000000e000e000e0000000e000e000e0000000e000e000e000000"\n        hex"0e000e000e0000000e000e000e0000000e000e0e0e0e0e0e0e0000";\n\n    /// @notice A bitpacked value of 8-bit words representing the notes of the\n    /// ending glissando synth line, where each note is a 1/32nd note, or 2048\n    /// ticks.\n    /// @dev A value of `0x05` corresponds to C3, and 1 corresponds to a\n    /// semitone. To attain the intended note value, it requires no\n    /// transpositions, so the `_pitch` parameter passed into `_synth` should be\n    /// set to `0`. Also, this value ranges 1/32nd notes with the indicies in\n    /// `[332, 347]`, where the `i - 332`th MSb is the corresponding data.\n    bytes internal constant SYNTH_GLISSANDO =\n        hex"0507090a0c0e101113151617191b1c1e";\n\n    // -------------------------------------------------------------------------\n    // Functions\n    // -------------------------------------------------------------------------\n\n    /// @notice Returns the WAV file header for the audio file for 1 full cycle\n    /// of the token\'s sound with the parameters the token\'s sound was generated\n    /// with:\n    /// * Size: 776.044921875kB (794670 bytes)\n    /// * Number of channels: 1\n    /// * Sample rate: 32000Hz\n    /// * Bits/sample: 8 bits/sample\n    function getAudioWavFileHeader() internal pure returns (bytes memory) {\n        // Note: base-64 encoding the following hex string yields:\n        // "UklGRi4gDABXQVZFZm10IBAAAAABAAEAAH0AAAB9AAABAAgAZGF0YQAgDACA".\n        return\n        // "RIFF" chunk descriptor\n        hex"52" hex"49" hex"46" hex"46" // "RIFF" in ASCII\n        hex"2e" hex"20" hex"0c" hex"00" // Size of the file (length of data chunk + 46 for the header) = 794624 + 46 = 794670\n        hex"57" hex"41" hex"56" hex"45" // "WAVE" in ASCII\n        // "fmt " sub-chunk\n        hex"66" hex"6d" hex"74" hex"20" // "fmt " in ASCII\n        hex"10" hex"00" hex"00" hex"00" // Length of sub-chunk 1 = 16\n        hex"01" hex"00" hex"01" hex"00" // Audio format = 1 (PCM), Number of channels = 1\n        hex"00" hex"7d" hex"00" hex"00" // Sample rate = 32000Hz\n        hex"00" hex"7d" hex"00" hex"00" // Byte rate (sample rate * bits/sample * channels) = (32000 * 8 * 1) / 8 = 32000 bytes/sec\n        hex"01" hex"00" hex"08" hex"00" // Block align = 1, bits/sample = 8\n        // "data" sub-chunk\n        hex"64" hex"61" hex"74" hex"61" // "data" in ASCII\n        hex"00" hex"20" hex"0c" hex"00" // Length of data chunk = (776 * 2**10 * 8 / 8) = 794624 bytes\n        hex"80"; // Sample 1\n    }\n\n    /// @notice Returns the sound value at a given time tick in the audio.\n    /// @dev {FiveFiveFive}\'s audio was generated at a sample rate of 32000Hz,\n    /// which means that `_tick` increments by 1 every 1/32000 seconds. A full\n    /// cycle of the audio is 776 * 2**10 = 794624 samples long, so `_tick`\n    /// wraps around every 794624 samples (i.e. same values for equivalent\n    /// `_tick % 794624`).\n    /// @param _tick The number of samples since the beginning of the audio at\n    /// a frequency of 32000Hz to get the sound value at.\n    /// @return The sound value at the given time tick, a value in the range\n    /// `[0, 255]` (higher means louder).\n    function getSoundValueAtSample(uint256 _tick) internal pure returns (uint8) {\n        uint256 tickWad;\n        uint256 n64;\n        uint256 n16;\n        uint256 n64x;\n        uint256 n64y;\n        assembly {\n            _tick := mod(_tick, shl(10, 776)) // `_tick % (776 << 10)`\n            n64 := mod(shr(10, _tick), 776) // `(_tick >> 10) % 776`\n            n16 := shr(2, n64) // `n64 >> 2`\n            tickWad := mul(_tick, 1000000000000000000) // `_tick * 1e18`\n            n64x := shr(3, n64) // `n64 >> 3`\n            n64y := sub(7, and(n64, 7)) // `7 - (n64 & 7)`\n        }\n\n        unchecked {\n            // Get whether each line is active at the given `_tick`.\n            bool synth1Active = (uint8(SYNTH_1_BEATMAP[n64x]) >> n64y) & 1 > 0;\n            bool synth2Active;\n            bool bass1Active = (uint8(BASS_1_BEATMAP[n64x]) >> n64y) & 1 > 0;\n            bool bass2Active = (uint8(BASS_2_BEATMAP[n64x]) >> n64y) & 1 > 0;\n            bool snareActive = n16 > 58 && n16 < 178;\n            uint256 snareN64;\n            assembly {\n                synth2Active := and(synth1Active, and(gt(n16, 15), lt(n16, 166)))\n                snareN64 := mul(snareActive, sub(n64, 236))\n            }\n            snareActive = snareActive && (uint8(SNARE_BEATMAP[snareN64 >> 3]) >> (7 - (snareN64 & 7))) & 1 > 0;\n\n            // If the line is active, compute the sound value of the note at the\n            // given `_tick`.\n            uint256 synth1 = synth1Active ? _synth(tickWad, _getNote(SYNTH_1_NOTES, n16), 0) : 0;\n            uint256 synth2 = synth2Active ? _synth(tickWad, _getNote(SYNTH_2_NOTES, n16), 2e18) : 0;\n            uint256 bass1 = bass1Active ? _synth(tickWad, _getNote(BASS_1_NOTES, n16), 4e18) : 0; \n            uint256 bass2 = bass2Active ? _synth(tickWad, _getNote(BASS_2_NOTES, n16), 4e18) : 0;\n            uint256 snare;\n            if (snareActive) {\n                snare = uint256(2e29).mulWad(tickWad.divWad(1e18 << 14));\n                snare = ((snare.mulWad(snare) / 1e18) & 255) / 10;\n            }\n            uint256 glissando = n16 > 165 && n16 < 174\n                ? _synth(tickWad, 1e18 * uint256(uint8(SYNTH_GLISSANDO[(n64 >> 1) - 332])), 0)\n                : 0;\n            uint256 ending = n16 > 173 ? _synth(tickWad, 21e18, 0) : 0;\n\n            // Finally, add all the lines together and return the result.\n            return uint8(synth1 + synth2 + bass1 + bass2 + snare + glissando + ending);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Helpers\n    // -------------------------------------------------------------------------\n\n    /// @notice Returns the note value of a note at a given 1/16th note index\n    /// of a given bitpacked value as an 18 decimal fixed-point number.\n    /// @param _data The bitpacked value of 8-bit words representing the notes\n    /// of a line.\n    /// @param _n16 The 1/16th note index of the note to get the value of.\n    /// @return The note value, as an 18 decimal fixed-point number.\n    function _getNote(bytes memory _data, uint256 _n16) internal pure returns (uint256) {\n        unchecked {\n            return 1e18 * uint256(uint8(_data[_n16]));\n        }\n    }\n\n    /// @notice Returns the sound value of a note of an 8-bit synth wave with\n    /// vibrato at a given time tick.\n    /// @dev Altogether, in pseudo-code, the function is equivalent to\n    /// `0.392 * (tick + 12 * sin(tick / 1600)) * 2 ** (note / 12 - pitch)`.\n    /// @param _tickWad The time tick at which to get the sound value, as an 18\n    /// decimal fixed-point value.\n    /// @param _note The note to get the sound value of, where C3 is 5, and 1\n    /// corresponds to a semitone, as an 18 decimal fixed-point value.\n    /// @param _pitch The number of octaves to transpose the note by, as an 18\n    /// decimal fixed-point value.\n    /// @return The sound value of the note at the given time tick, a value in\n    /// the range `[0, 15]` (higher means louder).\n    function _synth(uint256 _tickWad, uint256 _note, int256 _pitch) internal pure returns (uint8) {\n        // Next, calculate the vibration and sound value of the note at the\n        // given `_tickWad`.\n        unchecked {\n            // Equivalent to `tick + 12 * sin(tick / 1600)`.\n            int256 vibration = int256(_tickWad) + _sin(_tickWad.divWad(1600e18)).sMulWad(12e18);\n            // Equivalent to `2**(note / 12 - pitch)`.\n            int256 noteSoundValue = int256(2e18).powWad(int256(_note.divWad(12e18)) - _pitch);\n            // Equivalent to `0.392 * vibration * noteSoundValue`.\n            int256 soundValue = int256(0.392e18).sMulWad(vibration).sMulWad(noteSoundValue);\n            assembly {\n                // Equivalent to `soundValue / 1e18`.\n                soundValue := div(soundValue, 1000000000000000000)\n            }\n\n            // Here, we truncate the sound value with `& 32` and then halve it.\n            return uint8(uint256(soundValue.abs()) & 32) >> 1;\n        }\n    }\n\n    /// @notice An approximation of the `sin` function (with transformations)\n    /// that composes the helper function {FiveFiveFiveAudio._cos}.\n    /// @dev Since the Taylor series approximation of `cos` is only accurate for\n    /// half the domain, this function gets the other half by negating the\n    /// result depending on which half of the domain the input is in.\n    /// @param _x An 18 decimal fixed-point value.\n    /// @return The approximated value of `sin(_x)` as an 18 decimal fixed-point\n    /// value.\n    function _sin(uint256 _x) internal pure returns (int256) {\n        // `a` is the term to pass into the `_cos` function (before translating\n        // right by 2), and `b` is the coefficient to negate the result of the\n        // `_cos` function.\n        int256 a;\n        int256 b;\n        assembly {\n            // Equivalent to `_x % 4e18`.\n            a := mod(_x, 4000000000000000000)\n            // Equivalent to `(_x / 1e18) & 3 > 2 ? -1 : 1`.\n            b := add(mul(gt(and(div(_x, 1000000000000000000), 3), 2), sub(not(0), 1)), 1)\n        }\n\n        // Whether to negate the result of the `_cos` function (because we only\n        // get half the range from the Taylor series approximation).\n        unchecked {\n            return b * _cos(a - 2e18);\n        }\n    }\n\n    /// @notice Returns a 4-term Taylor series approximation for the `cos`\n    /// function.\n    /// @dev Altogether, in pseudo-code, the function is equivalent to\n    /// `1 - x**2/2! + x**4/4! - x**6/6!`.\n    /// @param _x An 18 decimal fixed-point value.\n    /// @return The approximated value of `cos(_x)` as an 18 decimal fixed-point\n    /// value.\n    function _cos(int256 _x) internal pure returns (int256) {\n        // First, calculate the 2nd, 4th, and 6th powers of `_x`.\n        int256 x2 = _x.sMulWad(_x);\n        int256 x4 = x2.sMulWad(x2);\n        int256 x6 = x2.sMulWad(x4);\n\n        // Next, calculate the 1st, 2nd, and 3rd terms of the Taylor series\n        // expansion of `cos(x)` around `x = 0`.\n        int256 t1 = x2.sDivWad(2e18);\n        int256 t2 = x4.sDivWad(24e18);\n        int256 t3 = x6.sDivWad(720e18);\n\n        // Finally, calculate the value of `cos(x)` using the Taylor series\n        // expansion.\n        unchecked {\n            return 1e18 - t1 + t2 - t3;\n        }\n    }\n}',
    metadata: {
      sampleRate: 32000,
      samples: 794624,
    },
  },
];
