import BlogHeader from '@/app/blog/(components)/header';

import { getBlogPageMetadata } from '@/lib/utils';

import { PerlinNoiseGenerator } from './client-components';
import { GolfBase2NFT } from './graphics';

export const metadata = getBlogPageMetadata({
  slug: "on-chain-worlds-with-terrain-generation",
  description: "Implementing on-chain worlds with terrain generation and hyper-optimized pixel art."
});

<BlogHeader slug="on-chain-worlds-with-terrain-generation" />

I gave myself an interesting challenge while designing the NFTs for [Curta Golf](https://github.com/waterfall-mkt/curta-golf).
[Curta](https://curta.wtf) is a fully on-chain competitive programming platform with some of the best smart contract engineers and security researchers, and Golf was the 2nd competitive format we added.
The goal for players is to submit [gas-optimized](https://www.evm.codes) (i.e. "gas-golfed") solutions to challenges, and the "King of the Hill" NFT gets transferred to them if they submit the best solution (i.e. lowest gas usage).

There's a couple of reasons I decided to make Curta fully on-chain from novelty to [my appreciation](https://gallery.so/fiveoutofnine/galleries/2dXu2CmM2LHQOceZKfh3MYxF36m) for [fully on-chain projects](https://www.fiveoutofnine.com/blog/on-chain-font), but the main one was because it'd maximize meritocratic competition.
Anyone can see the challenges at the same time on-chain, and anyone can submit solutions with the same conditions.
_You_ can even go improve the current best solution [right now](https://curta.wtf/golf/2).
So, with this philosophy and other motivators such as provenance and openness, there was no question whether the corresponding NFT's metadata would be on-chain or off-chain.

## Concept

My ideas on art concepts were immediately scoped by 2 things:
1. I wanted to create something following the "golfing" theme.
2. I wanted to learn a couple new techniques for making fully on-chain art.

When I think of golf, the first things I think of are golf courses and how every course is different with its own set of difficulties&mdash;just like how every Curta Golf challenge is different.

I've also been wanting to learn about terrain generation algorithms and on-chain (i.e. optimized) pixel art, so what if I made a generative, pixel art "worlds"?
That'd feel each NFT was visually representing each "golf course" (i.e. the challenge) and require me to understand and implement two new techniques.

### Sanity checking

I liked the generative worlds idea and concept, so I decided to sanity check it to see how hard it'd be or how long it'd take.
Doing things fully on-chain obviously places some restrictions, but I try to never bound my thinking while ideating cause you can work around them 99% of the time.
In fact, it [often leads to many interesting and fun solutions along the way](https://x.com/i/status/1772697738552971440).
Despite that, once I have a concept, I still have to perform some quick sanity checks to decide if I should dive deeper.
This can often just be like 3 seconds of thinking or even just "vibe"-based (i.e. does it _feel_ possible/easy), but it's an important chain of thoughts.

The process was mostly vibe-based for this project, probably because I had some feeling that there's no way terrain generation can be that complex for small outputs if games do it at a level and speed magnitudes higher.
At the very least, terrain generation with constrained compute resources must be a very well-studied and well-documented area, so I should be able to figure something out&mdash;especially since we have "unlimited" gas budget because the art renderer is a read function.

### Design

I played around with a few designs, but this what I ended up shipping:

<GolfBase2NFT id={2n} />

It has the generative world, and it clearly displays the important metrics of the leading solution.

## Terrain generation

I began researching terrain generation first because it was the bulk of the logic, and I figured mapping the algorithm's output to the corresponding pixel data would be easy.
Pretty quickly, I came across a great video on YouTube called [Minecraft terrain generation in a nutshell](https://youtu.be/CSa5O6knuwI) by [Henrik Kniberg](https://x.com/henrikkniberg).

I recommend Henrik's video for a deeper explanation, but the most important ideas are to:
1. Use an algorithm like a 2D [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise) map for smooth random values.
2. Map terrain using a combination of multiple 2D maps' values.

### Smooth randomness

The main challenge with terrain generation is to smoothly transition between different biomes.
If you naively generate worlds by randomly selecting tiles, the outputs won't be realistic.
For example, if an "ocean" tile gets placed right next to a "desert" tile, that wouldn't make much sense.
With a Perlin noise map, you can essentially generate a grid of random values that transition smoothly to adjacent values.

<PerlinNoiseGenerator />

### Terrain selection

Once we have the random values, we need to map the value at each tile index to the terrain value (i.e. which biome to render).

## Implementing and prototyping terrain generation

## Pixel art

## Mapping terrain generation to pixel art

## Conclusion
