import Image from 'next/image';

import BlogHeader from '@/app/blog/(components)/header';

import { getBlogPageMetadata } from '@/lib/utils';

import { PerlinNoiseGenerator } from './client-components';
import { GolfBase2NFT, TerrainTileMappingGraphic } from './graphics';

export const metadata = getBlogPageMetadata({
  slug: "on-chain-worlds-with-terrain-generation",
  description: "Implementing on-chain worlds with terrain generation and hyper-optimized pixel art."
});

<BlogHeader slug="on-chain-worlds-with-terrain-generation" />

I gave myself an interesting challenge while designing the NFTs for [Curta Golf](https://github.com/waterfall-mkt/curta-golf).
[Curta](https://curta.wtf) is a fully on-chain competitive programming platform with some of the best smart contract engineers and security researchers, and Golf was the 2nd competitive format we added.
The goal for players is to submit [gas-optimized](https://www.evm.codes) (i.e. "gas-golfed") solutions to challenges, and the "King of the Hill" NFT gets transferred to them if they submit the best solution (i.e. lowest gas usage).

There's a couple of reasons I decided to make Curta fully on-chain from novelty to [my appreciation](https://gallery.so/fiveoutofnine/galleries/2dXu2CmM2LHQOceZKfh3MYxF36m) for [fully on-chain projects](https://www.fiveoutofnine.com/blog/on-chain-font), but the main one was because it'd maximize meritocratic competition.
Anyone can see the challenges at the same time on-chain, and anyone can submit solutions with the same conditions.
_You_ can even go improve the current best solution [right now](https://curta.wtf/golf/2).
So, with this philosophy and other motivators such as provenance and openness, there was no question whether the corresponding NFT's metadata would be on-chain or off-chain.

## Concept

My ideas on art concepts were immediately scoped by 2 things:
1. I wanted to create something following the "golfing" theme.
2. I wanted to learn a couple new techniques for making fully on-chain art.

When I think of golf, the first things I think of are golf courses and how every course is different with its own set of difficulties&mdash;just like how every Curta Golf challenge is different.

I've also been wanting to learn about terrain generation algorithms and on-chain (i.e. optimized) pixel art, so what if I made generative, pixel art "worlds"?
That'd feel like each NFT was visually representing a "golf course" (i.e. the challenge) and require me to understand and implement two new techniques.

### Sanity checking

I liked the generative worlds idea and concept, so I decided to sanity check it to see how hard it'd be or how long it'd take.
Doing things fully on-chain obviously places some restrictions, but I try to never bound my thinking while ideating cause you can work around them 99% of the time.
In fact, it [often leads to many interesting and fun solutions along the way](https://x.com/i/status/1772697738552971440).
Despite that, once I have a concept, I still have to perform some quick sanity checks to decide if I should dive deeper.
This can often just be like 3 seconds of thinking or even just "vibe"-based (i.e. does it _feel_ possible/easy), but it's an important chain of thoughts.

The process was mostly vibe-based for this project, probably because I had some feeling that there's no way terrain generation can be that complex for small outputs if games do it at a complexity and speed magnitudes higher.
At the very least, terrain generation with constrained compute resources must be a very well-studied and well-documented area, so I should be able to figure something out&mdash;especially since we have "unlimited" gas budget because the art renderer is a read function.

### Design

I played around with a few designs, but this what I ended up shipping:

<GolfBase2NFT id={2n} />

It has the generative world, and it clearly displays the important metrics of the leading solution.

## Terrain generation

I began researching terrain generation first because it was the bulk of the logic, and I figured mapping the algorithm's output to the corresponding pixel data would be easy.
Pretty quickly, I came across a great video on YouTube called "[Minecraft terrain generation in a nutshell](https://youtu.be/CSa5O6knuwI)" by [Henrik Kniberg](https://x.com/henrikkniberg).

I recommend Henrik's video for a deeper explanation, but the most important ideas are to:
1. Use an algorithm like a 2D [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise) map for smooth random values.
2. Map terrain using a combination of multiple 2D maps' values.

### Smooth randomness

The main challenge with terrain generation is to smoothly transition between different biomes.
If we naively generate worlds by randomly selecting tiles, the outputs won't be realistic.
For example, if an "ocean" tile gets placed right next to a "desert" tile, that wouldn't make much sense.
With a Perlin noise map, we can generate a grid of random values that transition smoothly to adjacent values.

<PerlinNoiseGenerator />

### Terrain selection

Once we have the random values, we need to map the value at each tile index to the terrain value (i.e. which biome to render).
We can already kinda see how a single 2D Perlin map resembles some natural, geographic formation, like a topographic map showing elevation.
By mapping values from a single map to a single _property_, we can build a simple framework to introduce more complex generation where we combine values from multiple maps to get smooth transitions between biomes.

<Image
  className="border border-gray-6 rounded-xl bg-gray-2 overflow-hidden my-0"
  src="/static/blog/on-chain-worlds-with-terrain-generation/henrik-multiple-perlin-maps.webp"
  alt="Screenshot from Henrik's video showing how multiple Perlin maps are used to generate Minecraft's biome distribution."
  width={1200}
  height={615}
  blurDataURL="data:image/webp;base64,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"
/>

For example, in a game with [complex terrain generation](https://minecraft.wiki/w/World_generation) like Minecraft, we might want to take into account many properties such as continentalness, erosion, peaks and valleys, temperature, and humidity at each position.
We can see from the image above that Minecraft's world generation algorithm achieves even more granularity by using different types of random maps for each property.

In my case, I just needed to select 1 biome value out of 11 at each tile position, so I went with just 2 2D Perlin maps: 1 for rainfall and 1 for temperature.
Then, I came up with the following mapping to combine the 2 values:

<div className="w-full flex justify-center">
  <TerrainTileMappingGraphic />
</div>

<Callout intent="none">
  The key point is that we now have a way to smoothly transition between terrains, taking into account both rainfall and temperature gradients.
</Callout>

Now, we can see how our algorithm will avoid placing contrasting biomes adjacently and generate more realistic outputs.
For example, it's super unlikely that a "Desert" tile gets placed next to a "Wetland" tile because they're far apart in both dimensions of the mapping, which makes sense intuitively: a desert is super dry and hot, while a wetland is super wet and cool.

## Implementing and prototyping terrain generation

At this point, I had a good idea of the solution, so I hacked together a [Foundry script](https://github.com/waterfall-mkt/curta-golf/blob/fab9799e7e8240d432ea6d6fad4307ca5b8c6a9f/script/PerlinNoiseTest.s.sol) outputting ASCII values (instead of the actual SVG pixel data URIs) to test and prototype it.
I wanted to get a quick sense of the implementation, do a quick sanity check, and fiddle around with the mapping to get better generations.

The script is pretty straightforward, except for the last part, where I used a bitmap to determine which tiles to exclude in the final output to achieve the hexagonal shape:

```sol fileName="PerlinNoiseTest.s.sol snippet" highlightLines={[37, 38, 39]}
// Select the tiles depending on `perlin1` and `perlin2` and generate
// the ASCII string.
string memory ascii_map = "";
for (uint256 row; row < HEIGHT; ++row) {
    string memory ascii_row = "";
    for (uint256 col; col < WIDTH; ++col) {
        // Normalize the Perlin noise values to the range [0, 59].
        uint256 temperature = 60 * (perlin1[col][row] - min1) / range1;
        uint256 rainfall = 60 * (perlin2[col][row] - min2) / range2;

        // Select the tile based on the temperature and rainfall.
        string memory tile = "";
        if (rainfall < 12) {
            tile = "@"; // Rainforest
        } else if (rainfall < 24) {
            if (temperature < 30) tile = "@"; // Rainforest
            else tile = "*"; // Wetland
        } else if (rainfall < 36) {
            if (temperature < 20) tile = "%"; // Temperate forest
            else if (temperature < 40) tile = "#"; // Boreal forest
            else tile = "+"; // Marsh
        } else if (rainfall < 48) {
            if (temperature < 30) tile = ":"; // Plains
            else tile = "="; // Grassland
        } else {
            if (temperature < 15) tile = "-"; // Desert
            else if (temperature < 30) tile = ":"; // Plains
            else if (temperature < 45) tile = "."; // Tundra
            else tile = "_"; // Snow
        }

        // Exclude the tile (i.e. print as ` `) if it is not part of the
        // island's shape. We determine whether a tile at a given
        // `(row, col)` is part of the island via a bitmap, where a `1`
        // at the LSb position equal to `12 * row + col` indicates the
        // tile is part of the island.
        if ((0x1f81fc3fc3fe7fe3fffff3fffff3fffff3ff7fe3fe3fc1fc1f8 >> (12 * row + col)) & 1 == 0) {
            tile = " ";
        }
        ascii_row = string.concat(ascii_row, tile, "   ");
    }
    // Append the row to the map, prepended with a ` ` if the row is
    // odd-numbered.
    ascii_map = string.concat(ascii_map, row & 1 == 1 ? "  " : "", ascii_row, "\n");
}

// Log the map.
console.log(ascii_map);
```

I ran it a couple of times, and it seemed to look good.
Now, all that's left was to encode the pixel art data for each tile in an easy way for us to map the value at each position to the tile.

## Pixel art

## Mapping terrain generation to pixel art

## Conclusion
