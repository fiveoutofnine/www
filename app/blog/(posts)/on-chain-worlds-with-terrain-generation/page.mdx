import Image from 'next/image';

import BlogHeader from '@/app/blog/(components)/header';

import { getBlogPageMetadata } from '@/lib/utils';

export const metadata = getBlogPageMetadata({
  slug: "on-chain-worlds-with-terrain-generation",
  description: "Implementing 100% on-chain worlds with terrain generation and hyper-optimized pixel art."
});

<BlogHeader slug="on-chain-worlds-with-terrain-generation" />

I gave myself an interesting challenge while designing the NFTs for [Curta Golf](https://github.com/waterfall-mkt/curta-golf).
[Curta](https://curta.wtf) is a fully on-chain competitive programming platform with some of the best smart contract engineers and security researchers, and Golf was the 2nd competitive format we added.
The goal for players is to submit [gas-optimized](https://www.evm.codes) (i.e. "gas-golfed") solutions to challenges, and the "King of the Hill" NFT gets transferred to them if they submit the best solution (i.e. lowest gas usage).

There's a couple of reasons I decided to make Curta fully on-chain from novelty to [my appreciation](https://gallery.so/fiveoutofnine/galleries/2dXu2CmM2LHQOceZKfh3MYxF36m) for [fully on-chain projects](https://www.fiveoutofnine.com/blog/on-chain-font), but the main one was because it'd maximize meritocratic competition.
Anyone can see the challenges at the same time on-chain, and anyone can submit solutions with the same conditions.
_You_ can even go improve the current best solution [right now](https://curta.wtf/golf/2).
So, with this philosophy and other motivators such as provenance and openness, there was no question whether the corresponding NFT's metadata would be on-chain or off-chain.

## Concept

My ideas on art concepts were immediately scoped by 2 things:
1. I wanted to create something following the "golfing" theme.
2. I wanted to learn a couple new techniques for making fully on-chain art.

When I think of golf, the first things I think of are golf courses and how every course is different with its own set of difficulties&mdash;just like how every Curta Golf challenge is different.

I've also been wanting to learn about terrain generation algorithms and on-chain (i.e. optimized) pixel art, so what if I made a generative, pixel art "worlds"?
That'd feel each NFT was visually representing each "golf course" (i.e. the challenge) and require me to understand and implement two new techniques.

### Sanity checking

I liked the generative worlds idea and concept, so I decided to sanity check it to see how hard it'd be or how long it'd take.
Doing things fully on-chain obviously places some restrictions, but I try to never bound my thinking while ideating cause you can work around them 99% of the time.
In fact, it [often leads to many interesting and fun solutions along the way](https://x.com/i/status/1772697738552971440).
Despite that, once I have a concept, I still have to perform some quick sanity checks to decide if I should dive deeper.
This can often just be like 3 seconds of thinking or even just "vibe"-based (i.e. does it _feel_ possible/easy), but it's an important chain of thoughts.

The process was mostly vibe-based for this project, probably because I had some feeling that there's no way terrain generation can be that complex for small outputs if games do it at a level and speed magnitudes higher.
At the very least, terrain generation with constrained compute resources must be a very well-studied and well-documented area, so I should be able to figure something out&mdash;especially since we have "unlimited" gas budget because the art renderer is a read function.

### Design

I played around with a few designs, but this is the one I ended up going with:

<div className="flex w-full items-center justify-center rounded-xl border border-gray-6 bg-gray-2 p-8">
  <Image
    src="/static/blog/on-chain-worlds-with-terrain-generation/golf-base-2.svg"
    alt="Curta Golf #2 King of the Hill NFT on Base."
    width={512}
    height={512}
  />
</div>

## Terrain generation

## Implementing and prototyping terrain generation

## Pixel art

## Mapping terrain generation to pixel art

## Conclusion
